// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createBaseUser = `-- name: CreateBaseUser :one
INSERT INTO users (name, external_id, timezone, gender, has_onboarded) VALUES ($1, $2, $3, $4, $5) RETURNING id, created_at, updated_at, name, external_id, timezone, gender, has_onboarded
`

type CreateBaseUserParams struct {
	Name         string `json:"name"`
	ExternalID   string `json:"externalID"`
	Timezone     string `json:"timezone"`
	Gender       Gender `json:"gender"`
	HasOnboarded bool   `json:"hasOnboarded"`
}

func (q *Queries) CreateBaseUser(ctx context.Context, arg CreateBaseUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createBaseUser,
		arg.Name,
		arg.ExternalID,
		arg.Timezone,
		arg.Gender,
		arg.HasOnboarded,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.ExternalID,
		&i.Timezone,
		&i.Gender,
		&i.HasOnboarded,
	)
	return i, err
}

const createUserNotifications = `-- name: CreateUserNotifications :one
INSERT INTO user_notifications (user_id, enabled, is_registered, daily_enabled, playtime_enabled) VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, enabled, is_registered, daily_enabled, playtime_enabled
`

type CreateUserNotificationsParams struct {
	UserID          uuid.UUID `json:"userID"`
	Enabled         bool      `json:"enabled"`
	IsRegistered    bool      `json:"isRegistered"`
	DailyEnabled    bool      `json:"dailyEnabled"`
	PlaytimeEnabled bool      `json:"playtimeEnabled"`
}

func (q *Queries) CreateUserNotifications(ctx context.Context, arg CreateUserNotificationsParams) (UserNotification, error) {
	row := q.db.QueryRow(ctx, createUserNotifications,
		arg.UserID,
		arg.Enabled,
		arg.IsRegistered,
		arg.DailyEnabled,
		arg.PlaytimeEnabled,
	)
	var i UserNotification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Enabled,
		&i.IsRegistered,
		&i.DailyEnabled,
		&i.PlaytimeEnabled,
	)
	return i, err
}

const createUserSubscription = `-- name: CreateUserSubscription :one
INSERT INTO user_subscriptions (user_id, trial_start_date, subscription_type, is_trial_mode) VALUES ($1, $2, $3, $4) RETURNING id, user_id, trial_start_date, subscription_type, is_trial_mode
`

type CreateUserSubscriptionParams struct {
	UserID           uuid.UUID        `json:"userID"`
	TrialStartDate   time.Time        `json:"trialStartDate"`
	SubscriptionType SubscriptionType `json:"subscriptionType"`
	IsTrialMode      bool             `json:"isTrialMode"`
}

func (q *Queries) CreateUserSubscription(ctx context.Context, arg CreateUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, createUserSubscription,
		arg.UserID,
		arg.TrialStartDate,
		arg.SubscriptionType,
		arg.IsTrialMode,
	)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TrialStartDate,
		&i.SubscriptionType,
		&i.IsTrialMode,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getInternalID = `-- name: GetInternalID :one
SELECT id FROM users where external_id = $1
`

func (q *Queries) GetInternalID(ctx context.Context, externalID string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getInternalID, externalID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT users.id, users.created_at, users.updated_at, users.name, users.external_id, users.timezone, users.gender, users.has_onboarded, user_subscriptions.id, user_subscriptions.user_id, user_subscriptions.trial_start_date, user_subscriptions.subscription_type, user_subscriptions.is_trial_mode, user_notifications.id, user_notifications.user_id, user_notifications.enabled, user_notifications.is_registered, user_notifications.daily_enabled, user_notifications.playtime_enabled
FROM users
LEFT JOIN user_subscriptions ON users.id = user_subscriptions.user_id
LEFT JOIN user_notifications ON users.id = user_notifications.user_id
WHERE users.id = $1
`

type GetUserByIDRow struct {
	User             User             `json:"user"`
	UserSubscription UserSubscription `json:"userSubscription"`
	UserNotification UserNotification `json:"userNotification"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.User.ID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Name,
		&i.User.ExternalID,
		&i.User.Timezone,
		&i.User.Gender,
		&i.User.HasOnboarded,
		&i.UserSubscription.ID,
		&i.UserSubscription.UserID,
		&i.UserSubscription.TrialStartDate,
		&i.UserSubscription.SubscriptionType,
		&i.UserSubscription.IsTrialMode,
		&i.UserNotification.ID,
		&i.UserNotification.UserID,
		&i.UserNotification.Enabled,
		&i.UserNotification.IsRegistered,
		&i.UserNotification.DailyEnabled,
		&i.UserNotification.PlaytimeEnabled,
	)
	return i, err
}
