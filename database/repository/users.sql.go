// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBaseUser = `-- name: CreateBaseUser :one
INSERT INTO users (name, external_id, timezone, gender, has_onboarded) VALUES ($1, $2, $3, $4, $5) RETURNING id, created_at, updated_at, name, external_id, timezone, gender, has_onboarded
`

type CreateBaseUserParams struct {
	Name         string `json:"name"`
	ExternalID   string `json:"externalID"`
	Timezone     string `json:"timezone"`
	Gender       Gender `json:"gender"`
	HasOnboarded bool   `json:"hasOnboarded"`
}

func (q *Queries) CreateBaseUser(ctx context.Context, arg CreateBaseUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createBaseUser,
		arg.Name,
		arg.ExternalID,
		arg.Timezone,
		arg.Gender,
		arg.HasOnboarded,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.ExternalID,
		&i.Timezone,
		&i.Gender,
		&i.HasOnboarded,
	)
	return i, err
}

const createUserNotifications = `-- name: CreateUserNotifications :one
INSERT INTO user_notifications (user_id, enabled, is_registered, daily_enabled, playtime_enabled) VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, enabled, is_registered, daily_enabled, playtime_enabled
`

type CreateUserNotificationsParams struct {
	UserID          uuid.UUID `json:"userID"`
	Enabled         bool      `json:"enabled"`
	IsRegistered    bool      `json:"isRegistered"`
	DailyEnabled    bool      `json:"dailyEnabled"`
	PlaytimeEnabled bool      `json:"playtimeEnabled"`
}

func (q *Queries) CreateUserNotifications(ctx context.Context, arg CreateUserNotificationsParams) (UserNotification, error) {
	row := q.db.QueryRow(ctx, createUserNotifications,
		arg.UserID,
		arg.Enabled,
		arg.IsRegistered,
		arg.DailyEnabled,
		arg.PlaytimeEnabled,
	)
	var i UserNotification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Enabled,
		&i.IsRegistered,
		&i.DailyEnabled,
		&i.PlaytimeEnabled,
	)
	return i, err
}

const createUserSubscription = `-- name: CreateUserSubscription :one
INSERT INTO user_subscriptions (user_id, trial_start_date, subscription_type, is_trial_mode) VALUES ($1, $2, $3, $4) RETURNING id, user_id, trial_start_date, subscription_type, is_trial_mode
`

type CreateUserSubscriptionParams struct {
	UserID           uuid.UUID        `json:"userID"`
	TrialStartDate   time.Time        `json:"trialStartDate"`
	SubscriptionType SubscriptionType `json:"subscriptionType"`
	IsTrialMode      bool             `json:"isTrialMode"`
}

func (q *Queries) CreateUserSubscription(ctx context.Context, arg CreateUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, createUserSubscription,
		arg.UserID,
		arg.TrialStartDate,
		arg.SubscriptionType,
		arg.IsTrialMode,
	)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TrialStartDate,
		&i.SubscriptionType,
		&i.IsTrialMode,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getInternalID = `-- name: GetInternalID :one
SELECT id FROM users where external_id = $1
`

func (q *Queries) GetInternalID(ctx context.Context, externalID string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getInternalID, externalID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT users.id, users.created_at, users.updated_at, users.name, users.external_id, users.timezone, users.gender, users.has_onboarded, user_subscriptions.id, user_subscriptions.user_id, user_subscriptions.trial_start_date, user_subscriptions.subscription_type, user_subscriptions.is_trial_mode, user_notifications.id, user_notifications.user_id, user_notifications.enabled, user_notifications.is_registered, user_notifications.daily_enabled, user_notifications.playtime_enabled
FROM users
LEFT JOIN user_subscriptions ON users.id = user_subscriptions.user_id
LEFT JOIN user_notifications ON users.id = user_notifications.user_id
WHERE users.id = $1
`

type GetUserByIDRow struct {
	User             User             `json:"user"`
	UserSubscription UserSubscription `json:"userSubscription"`
	UserNotification UserNotification `json:"userNotification"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.User.ID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Name,
		&i.User.ExternalID,
		&i.User.Timezone,
		&i.User.Gender,
		&i.User.HasOnboarded,
		&i.UserSubscription.ID,
		&i.UserSubscription.UserID,
		&i.UserSubscription.TrialStartDate,
		&i.UserSubscription.SubscriptionType,
		&i.UserSubscription.IsTrialMode,
		&i.UserNotification.ID,
		&i.UserNotification.UserID,
		&i.UserNotification.Enabled,
		&i.UserNotification.IsRegistered,
		&i.UserNotification.DailyEnabled,
		&i.UserNotification.PlaytimeEnabled,
	)
	return i, err
}

const updateBaseUser = `-- name: UpdateBaseUser :exec
UPDATE users
SET
    name = COALESCE($1, name),
    external_id = COALESCE($2, external_id),
    timezone = COALESCE($3, timezone),
    gender = COALESCE($4, gender),
    has_onboarded = COALESCE($5, has_onboarded)
WHERE id = $6
`

type UpdateBaseUserParams struct {
	Name         pgtype.Text `json:"name"`
	ExternalID   pgtype.Text `json:"externalID"`
	Timezone     pgtype.Text `json:"timezone"`
	Gender       NullGender  `json:"gender"`
	HasOnboarded pgtype.Bool `json:"hasOnboarded"`
	ID           uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateBaseUser(ctx context.Context, arg UpdateBaseUserParams) error {
	_, err := q.db.Exec(ctx, updateBaseUser,
		arg.Name,
		arg.ExternalID,
		arg.Timezone,
		arg.Gender,
		arg.HasOnboarded,
		arg.ID,
	)
	return err
}

const updateUserNotifications = `-- name: UpdateUserNotifications :exec
UPDATE user_notifications
SET
    enabled = COALESCE($1, enabled),
    is_registered = COALESCE($2, is_registered),
    daily_enabled = COALESCE($3, daily_enabled),
    playtime_enabled = COALESCE($4, playtime_enabled)
WHERE id = $5
`

type UpdateUserNotificationsParams struct {
	Enabled         pgtype.Bool `json:"enabled"`
	IsRegistered    pgtype.Bool `json:"isRegistered"`
	DailyEnabled    pgtype.Bool `json:"dailyEnabled"`
	PlaytimeEnabled pgtype.Bool `json:"playtimeEnabled"`
	ID              uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateUserNotifications(ctx context.Context, arg UpdateUserNotificationsParams) error {
	_, err := q.db.Exec(ctx, updateUserNotifications,
		arg.Enabled,
		arg.IsRegistered,
		arg.DailyEnabled,
		arg.PlaytimeEnabled,
		arg.ID,
	)
	return err
}

const updateUserPetLink = `-- name: UpdateUserPetLink :exec
UPDATE users_pets_link
SET
    is_dog_owner = COALESCE($1, is_dog_owner),
    is_dog_sitter = COALESCE($2, is_dog_sitter),
    user_id = COALESCE($3, user_id),
    pet_id = COALESCE($4, pet_id)
WHERE id = $5
`

type UpdateUserPetLinkParams struct {
	IsDogOwner  pgtype.Bool `json:"isDogOwner"`
	IsDogSitter pgtype.Bool `json:"isDogSitter"`
	UserID      pgtype.UUID `json:"userID"`
	PetID       pgtype.UUID `json:"petID"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateUserPetLink(ctx context.Context, arg UpdateUserPetLinkParams) error {
	_, err := q.db.Exec(ctx, updateUserPetLink,
		arg.IsDogOwner,
		arg.IsDogSitter,
		arg.UserID,
		arg.PetID,
		arg.ID,
	)
	return err
}

const updateUserSubscription = `-- name: UpdateUserSubscription :exec
UPDATE user_subscriptions
SET
    trial_start_date = COALESCE($1, trial_start_date),
    subscription_type = COALESCE($2, subscription_type),
    is_trial_mode = COALESCE($3, is_trial_mode)
WHERE id = $4
`

type UpdateUserSubscriptionParams struct {
	TrialStartDate   pgtype.Date          `json:"trialStartDate"`
	SubscriptionType NullSubscriptionType `json:"subscriptionType"`
	IsTrialMode      pgtype.Bool          `json:"isTrialMode"`
	ID               uuid.UUID            `json:"id"`
}

func (q *Queries) UpdateUserSubscription(ctx context.Context, arg UpdateUserSubscriptionParams) error {
	_, err := q.db.Exec(ctx, updateUserSubscription,
		arg.TrialStartDate,
		arg.SubscriptionType,
		arg.IsTrialMode,
		arg.ID,
	)
	return err
}
